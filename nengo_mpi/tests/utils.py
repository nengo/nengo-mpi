import inspect
import re
import os
import h5py
import subprocess
import numpy as np


def run_standalone_cpp(network_file, log_file, sim_time):
    """ Execute a standalone simulation using nengo_cpp.

    Assumes the executable nengo_cpp can be found and that a file storing
    a nengo network (created using nengo_mpi.Simulator) called `network_file`
    exists.
    """

    try:
        subprocess.check_output([
            'nengo_cpp', '--log', log_file,
            '--noprog', network_file, str(sim_time)])

        with h5py.File(log_file, 'r') as results:
            probe_dict = {}
            for probe_key, probe_data in results.iteritems():
                probe_dict[probe_key] = np.array(probe_data, copy=True)

        return probe_dict

    finally:
        try:
            os.remove(log_file)
        except:
            pass


def run_standalone_mpi(network_file, log_file, n_processors, sim_time):
    """ Execute a standalone simulation using nengo_mpi.

    Assumes the executable nengo_mpi can be found and that a file storing
    a nengo network (created using nengo_mpi.Simulator) called `network_file`
    exists.
    """
    try:
        subprocess.check_output([
            'mpirun', '-np', str(n_processors), 'nengo_mpi',
            '--log', log_file, '--noprog', network_file, str(sim_time)])

        with h5py.File(log_file, 'r') as results:
            probe_dict = {}
            for probe_key, probe_data in results.iteritems():
                probe_dict[probe_key] = np.array(probe_data, copy=True)

        return probe_dict

    finally:
        try:
            os.remove(log_file)
        except:
            pass


def run_python_mpi(n_processors, script_name, script_args):
    """ Execute a script in the nengo_mpi context.

    Returns: (script output, exit code)
    """
    if isinstance(script_args, str):
        script_args = script_args.split(' ')

    try:
        output = subprocess.check_output([
            'mpirun', '-np', str(n_processors), 'python',
            '-m', 'nengo_mpi', script_name] + script_args)
        return output, 0
    except subprocess.CalledProcessError as e:
        return e.output, e.returncode


# Note: Copied this from nengo_ocl.
# The version of this function in Nengo 2.0 has a bug, so an updated version
# has been put here. This can be removed when the fix has been made in Nengo.
def load_functions(modules, pattern='^test_', arg_pattern='^Simulator$'):
    """Load matching functions from a list of modules.

    Parameters
    ----------
    modules : list
        A list of testing modules to load, generated by `find_testmodules`.
    pattern : string, optional
        A regex pattern for matching the function names. Defaults to looking
        for all testing functions.
    arg_pattern : string, optional
        A regex pattern for matching the argument names. At least one argument
        must match the pattern. Defaults to selecting tests with
        a 'Simulator' argument.

    Returns
    -------
    tests : dict
        A dictionary of test functions, where the key is composed of the
        module and function name, and the value is the function handle.

    Examples
    --------
    To load all Nengo tests and add them to the current namespace, do

        nengo_dir = os.path.dirname(nengo.__file__)
        modules = find_modules(nengo_dir, prefix='nengo')
        tests = load_functions(modules)
        locals().update(tests)

    Notes
    -----
    - This was created to load py.test tests. Therefore, this function also
      loads functions that start with `pytest`, since these functions act as
      hooks into py.test.
    - TODO: currently, all `pytest` functions are loaded into the same
      namespace, which means that if two different files imlement the same
      py.test hook, only the latter of these will be respected.
    - TODO: py.test also allows test functions to be implemented in classes;
      these tests cannot currently be loaded by this function.
    """
    tests = {}
    for module in modules:
        try:
            m = __import__('.'.join(module), globals(), locals(), ['*'])
        except:
            print "Failed to import %s." % module
            continue

        for k in dir(m):
            test = getattr(m, k)
            if callable(test) and re.search(pattern, k):
                args = inspect.getargspec(test).args
                if any(re.search(arg_pattern, arg) for arg in args):
                    tests['.'.join(['test'] + module + [k])] = test
            if k.startswith('pytest'):  # automatically load py.test hooks
                # TODO: different files with different implementations of the
                #   same pytest hook will break here!
                tests[k] = getattr(m, k)

    return tests
